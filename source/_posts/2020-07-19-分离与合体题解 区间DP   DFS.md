---
layout: post
title: "「Solution」分离与合体"
date: 2020-07-19
categories: 区间DP
tags: [区间DP, DFS]
image: http://gastonsanchez.com/images/blog/mathjax_logo.png
---

##### 题目描述
经过在机房里数日的切磋，LYD 从杜神牛那里学会了分离与合体，出关前，杜神牛给了他一个测试……<!-- more -->
杜神牛造了n 个区域，他们紧邻着排成一行，编号 1 ~ n  。在每个区域里都放着一把 OI 界的金钥匙，每一把都有一定的价值，LYD 当然想得到他们了。然而杜神牛规定 LYD 不能一下子把他们全部拿走，而是每次只可以拿一把。为了尽快得到所有金钥匙，LYD 自然就用上了刚学的分离与合体特技。
一开始 LYD 可以选择 1 ... n - 1 中的任何一个区域进入，我们不妨把这个区域记为k 。进入后 LYD 会在  区域发生分离，从而分离成两个小 LYD。分离完成的同时会有一面墙在 k 区域和 k + 1 区域间升起，从而把1...k  和 k + 1 ... n 阻断成两个独立的区间，并在各自区间内任选除区间末尾之外（即从 1..k-1 和 k+1...n-1中选取）的任意一个区域再次发生分离，这样就有了四个小小 LYD……重复以上所叙述的分离，直到每个小 LYD 发现自己所在的区间只剩下了一个区域，那么他们就可以抱起自己梦寐以求的 OI 金钥匙。
但是 LYD 不能就分成这么多个个体存在于世界上，这些小 LYD 还会再合体，合体的小 LYD 所在区间中间的墙会消失。合体会获得 合并后所在区间左右端区域里金钥匙价值之和之前分离的时候所在区域的金钥匙价值。
LYD 请你编程求出最终可以获得的最大总价值，并按照分离阶段从前到后，区域从左到右的顺序，输出发生分离区域编号。若有多种方案，选择分离区域尽量靠左的方案（也可以理解为输出字典序最小的）。
例如先打印一分为二的区域，然后从左到右打印二分为四的分离区域，然后是四分为八的……
##### 输入格式
第一行一个正整数n  第二行 n 个用空格分开的正整数 $a_i$  ，表示  区域里每把金钥匙的价值。
##### 输出格式
第一行一个数，表示获得的最大价值
第二行按照分离阶段从前到后，区域从左到右的顺序，输出发生分离区域编号。若有多种方案，选择分离区域尽量靠左的方案（也可以理解为输出字典序最小的）。

##### 样例
###### 样例输入
7
1 2 3 4 5 6 7
###### 样例输出
238
1 2 3 4 5 6
数据范围与提示
对于100\% 的数据，$n_i$，$a_i$保证运算过程和结果不超过 $int$ 位正整数范围。

### 思路分析
首先，求出获得的最大价值可以直接通过区间DP得到，只是将合并石子的条件做了改动。
可以设$dp[i, j]$是从第$i$个区域到第$j$个区域之间获得的最大价值。
状态转移方程为：

$dp[i,j]=dp[i,k]+dp[k+1,j]+a[i]*a[k]*a[j]$
$(1<=i<=n-len+1, j=i+len-1, i<=k<j)$

参考代码：

```cpp
for(int len = 2;len <= n; len++) {
		for(int i = 1;i <= n - len + 1; i++) {
			int j = i + len - 1;
			for(int k = i;k < j; k++) {
				if(dp[i][k] + dp[k + 1][j] + (a[i] + a[j]) * a[k] > dp[i][j]) {
					dp[i][j] = dp[i][k] + dp[k + 1][j] + (a[i] + a[j]) * a[k];
					pre[i][j] = k;
				}
			}
		}
	}
	printf("%d\n", dp[1][n]);
```

重点在于如何输出路径。
注意读题：
#### 求出最终可以获得的最大总价值，并按照分离阶段从前到后，区域从左到右的顺序，输出发生分离区域编号。若有多种方案，选择分离区域尽量靠左的方案（也可以理解为输出字典序最小的）。例如先打印一分为二的区域，然后从左到右打印二分为四的分离区域，然后是四分为八的……
### 也就是说需要倒着输出，从最后的划分点往回找，先递归输出左边，再输出右边。
结果考试的时候以为要从左往右输出，于是所有的输出都是从1~n-1...   又因为一些bug导致基本没得分。。。   
输出可以用dfs，从最后一个划分点往回找。

定义$dfs(x, y, end)$,$x$表示左边界，$y$表示右边界，$end$ 表示划分次数。
要配合使用一个$while$循环，原理如下

1.定义一个$h$表示输出的序号，每轮循环+1,与$dfs$中的$end$配合，保证输出的顺序不乱，将$h$初始化为0，$flag$置为1.
2.进入循环 {
-  先把flag置为0：如果在dfs中满足了h == end即现在的划分次数$end$刚好等于		  此时应该为的划分次数$h$，即可以将它置为1。
- 再把h++，更新划分点的次数。
- 进行$dfs(1， n， 1)$.
3.dfs(.......) {
- 如果左端点大于等于了右端点，那么就return ;
- 如果如果在dfs中满足了h == end即现在的划分次数$end$刚好等于此时应该为的划分次数$h$，（以确保顺序没乱）
- 就可以将$pre[x, y]$输出。
- 然后递归输出左半部分，在输出右半部分  （血的教训告诉我要审题。。。）
- 左半部分边界：左端点为$x$，右端点为$pre[x][y]$,end++.
- 左半部分边界：左端点为$pre[x][y]+1$，右端点为$y$,end++.
  <font color = white> tab       </font>}
}

参考代码：
```cpp
void dfs(int x, int y, int end) {
	if (x >= y) return;
	if (end == h) {
		printf("%d ", pre[x][y]);
		flag = 1;
		return;
	}
	dfs(x, pre[x][y], end + 1);
	dfs(pre[x][y] + 1, y, end + 1);
}
flag = 1;
while(flag) {
	flag = 0;
	h ++;
	dfs(1, n, 1);
}
```

